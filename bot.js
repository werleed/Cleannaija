// bot.js require('dotenv').config();

const fs = require('fs'); const fsExtra = require('fs-extra'); const path = require('path'); const express = require('express'); const TelegramBot = require('node-telegram-bot-api'); const twilio = require('twilio'); const axios = require('axios');

// --- Environment / config --- const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN || process.env.BOT_TOKEN; const ADMIN_TELEGRAM_ID = process.env.ADMIN_TELEGRAM_ID ? parseInt(process.env.ADMIN_TELEGRAM_ID, 10) : null; const TWILIO_ACCOUNT_SID = process.env.TWILIO_ACCOUNT_SID || ''; const TWILIO_AUTH_TOKEN = process.env.TWILIO_AUTH_TOKEN || ''; const TWILIO_VERIFY_SID = process.env.TWILIO_VERIFY_SID || ''; const PORT = process.env.PORT ? parseInt(process.env.PORT, 10) : 8080;

if (!TELEGRAM_TOKEN) { console.error('FATAL: TELEGRAM_TOKEN (or BOT_TOKEN) missing in environment.'); process.exit(1); }

// --- Paths and files --- const DATA_DIR = path.join(__dirname, 'data'); const UPLOADS_DIR = path.join(__dirname, 'uploads'); fsExtra.ensureDirSync(DATA_DIR); fsExtra.ensureDirSync(UPLOADS_DIR);

const USERS_FILE = path.join(DATA_DIR, 'users.json'); const SETTINGS_FILE = path.join(DATA_DIR, 'settings.json'); if (!fs.existsSync(USERS_FILE)) fs.writeFileSync(USERS_FILE, '[]', 'utf8'); if (!fs.existsSync(SETTINGS_FILE)) { const defaults = { verification_enabled: true, withdrawals_enabled: true, language_default: 'en' }; fs.writeFileSync(SETTINGS_FILE, JSON.stringify(defaults, null, 2), 'utf8'); }

// --- Simple storage helpers --- const loadJSON = (p) => { try { return JSON.parse(fs.readFileSync(p, 'utf8') || 'null') || {}; } catch (e) { return {}; } }; const saveJSON = (p, obj) => fs.writeFileSync(p, JSON.stringify(obj, null, 2), 'utf8'); const loadUsers = () => { try { return JSON.parse(fs.readFileSync(USERS_FILE, 'utf8') || '[]'); } catch (e) { return []; } }; const saveUsers = (arr) => fs.writeFileSync(USERS_FILE, JSON.stringify(arr, null, 2), 'utf8');

// --- Twilio client (if configured) --- let twilioClient = null; if (TWILIO_ACCOUNT_SID && TWILIO_AUTH_TOKEN) { try { twilioClient = twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN); } catch (e) { twilioClient = null; } }

// --- Telegram bot --- // Use polling mode (you previously chose polling). We catch polling errors and exit cleanly when unauthorized. const bot = new TelegramBot(TELEGRAM_TOKEN, { polling: true });

// --- Languages/messages (EN, FR, HA, YO, AK/TWI) --- const MESSAGES = { en: { welcome_unverified: (n) => üëã Welcome ${n || ''}! Please verify your phone., otp_sent: (p) => üì® Code sent to ${p}, otp_failed: ‚ùå Failed to send OTP., verified_ok: ‚úÖ Phone verified! Use /menu, already_verified: ‚úÖ Already verified!, need_verify: ‚ö†Ô∏è Verify first using /start, main_menu: Main Menu:, recorded: (kg, naira) => ‚úÖ Recorded ${kg}kg ‚Äî ‚Ç¶${naira.toFixed(2)} earned., min_withdraw: ‚ö†Ô∏è Minimum ‚Ç¶1000 to withdraw., withdraw_received: ‚úÖ Withdrawal request sent., stats: (t, b) => üìà Waste: ${t}kg\nüí∞ Balance: ‚Ç¶${b.toFixed(2)} }, fr: { welcome_unverified: (n) => üëã Bienvenue ${n || ''} ! Veuillez v√©rifier votre num√©ro., otp_sent: (p) => üì® Code envoy√© √† ${p}, otp_failed: ‚ùå √âchec de l'envoi de l'OTP., verified_ok: ‚úÖ T√©l√©phone v√©rifi√© !, already_verified: ‚úÖ D√©j√† v√©rifi√© !, need_verify: ‚ö†Ô∏è V√©rifiez d'abord avec /start, main_menu: Menu Principal:, recorded: (kg, naira) => ‚úÖ ${kg}kg enregistr√© ‚Äî ‚Ç¶${naira.toFixed(2)} gagn√©s., min_withdraw: ‚ö†Ô∏è Retrait min ‚Ç¶1000., withdraw_received: ‚úÖ Demande re√ßue., stats: (t, b) => üìà Total: ${t}kg\nüí∞ Solde: ‚Ç¶${b.toFixed(2)} }, ha: { welcome_unverified: (n) => üëã Barka da zuwa ${n || ''}! Da fatan za a tabbatar da lambar wayarka., otp_sent: (p) => üì® An aika lambar zuwa ${p}, otp_failed: ‚ùå Aika OTP ya gagara., verified_ok: ‚úÖ An tabbatar da wayarka!, already_verified: ‚úÖ An riga an tabbatar!, need_verify: ‚ö†Ô∏è Da fatan za a tabbatar da wayarka da /start, main_menu: Babban Menu:, recorded: (kg, naira) => ‚úÖ An adana ${kg}kg ‚Äî ‚Ç¶${naira.toFixed(2)}., min_withdraw: ‚ö†Ô∏è Akalla ‚Ç¶1000 ne za a iya cirewa., withdraw_received: ‚úÖ An karbi bukatar cire kudi., stats: (t, b) => üìà Jimlar Shara: ${t}kg\nüí∞ Ma'auni: ‚Ç¶${b.toFixed(2)} }, yo: { welcome_unverified: (n) => üëã Kaabo ${n || ''}! Jowo j·∫πrisi n·ªçmba foonu r·∫π., otp_sent: (p) => üì® A fi koodu ran·π£·∫π si ${p}, otp_failed: ‚ùå Koodu OTP ko ·π£i·π£·∫π., verified_ok: ‚úÖ A ti j·∫πrisi foonu!, already_verified: ‚úÖ A ti j·∫πrisi r·∫π t·∫πl·∫π!, need_verify: ‚ö†Ô∏è J·ªçw·ªç j·∫πrisi foonu r·∫π p·∫πlu /start, main_menu: Ibi Akoj·ªç:, recorded: (kg, naira) => ‚úÖ A gba ${kg}kg ‚Äî ‚Ç¶${naira.toFixed(2)}., min_withdraw: ‚ö†Ô∏è O kere ju ‚Ç¶1000 lati y·ªçkuro., withdraw_received: ‚úÖ A gba ibeere yiy·ªçkuro., stats: (t, b) => üìà Apap·ªç: ${t}kg\nüí∞ I·π£ura: ‚Ç¶${b.toFixed(2)} }, ak: { welcome_unverified: (n) => üëã Akwaaba ${n || ''}! Mepa wo ky…õw, kyer…õw wo phone., otp_sent: (p) => üì® Code somaa k…î ${p}, otp_failed: ‚ùå OTP sending failed., verified_ok: ‚úÖ Phone aye!, already_verified: ‚úÖ Wo ho akyerew dada!, need_verify: ‚ö†Ô∏è Fa /start na y…õ verification, main_menu: Main Menu:, recorded: (kg, naira) => ‚úÖ ${kg}kg akyer…õw ‚Äî ‚Ç¶${naira.toFixed(2)}., min_withdraw: ‚ö†Ô∏è Minimum withdrawal ‚Ç¶1000., withdraw_received: ‚úÖ Withdrawal request ad…î., stats: (t, b) => üìà Total: ${t}kg\nüí∞ Balance: ‚Ç¶${b.toFixed(2)} } }; const langFor = (user) => (user && user.language) || loadJSON(SETTINGS_FILE).language_default || 'en'; const message = (key, user, ...a) => { const lang = langFor(user); const entry = MESSAGES[lang] && MESSAGES[lang][key] ? MESSAGES[lang][key] : MESSAGES['en'][key]; return typeof entry === 'function' ? entry(...a) : entry || ''; };

console.log(new Date().getFullYear(), 'Starting in POLLING mode.'); console.log('ü§ñ Bot started successfully (POLLING mode)...');

// --- Helpers for country detection --- function detectCountryFromPhone(phone) { if (!phone) return null; const p = String(phone).replace(/\s+/g, ''); if (p.startsWith('+234') || p.startsWith('234')) return { code: 'NG', name: 'Nigeria üá≥üá¨' }; if (p.startsWith('+233') || p.startsWith('233')) return { code: 'GH', name: 'Ghana üá¨üá≠' }; return null; } function detectCountryFallback(from) { if (!from) return null; const lang = (from.language_code || '').toLowerCase(); if (lang.startsWith('fr')) return { code: 'FR', name: 'French' }; if (lang.startsWith('en')) return { code: 'EN', name: 'English' }; return null; }

// --- /start handler --- bot.onText(//start/, (msg) => { const chatId = msg.chat.id; let users = loadUsers(); let user = users.find(u => u.telegram_id === chatId); if (!user) { user = { telegram_id: chatId, verified: false, phone: null, balance: 0, total_waste: 0, awaiting_otp: false, awaiting_waste: false, awaiting_withdraw: false, language: loadJSON(SETTINGS_FILE).language_default || 'en' }; users.push(user); saveUsers(users); } const country = detectCountryFromPhone(user.phone) || detectCountryFallback(msg.from) || null; if (country) bot.sendMessage(chatId, message('detected_country', user, country.name)).catch(() => {}); if (!user.verified && loadJSON(SETTINGS_FILE).verification_enabled) { return bot.sendMessage(chatId, message('welcome_unverified', user, msg.from.first_name), { reply_markup: { keyboard: [[{ text: "üì± Share My Number", request_contact: true }], [{ text: "Type phone number" }]], resize_keyboard: true, one_time_keyboard: true } }); } return bot.sendMessage(chatId, message('already_verified', user)); });

// --- contact share handler --- bot.on('contact', async (msg) => { const chatId = msg.chat.id; const phone = msg.contact && msg.contact.phone_number; if (!phone) return bot.sendMessage(chatId, "Invalid contact received."); const users = loadUsers(); const user = users.find(u => u.telegram_id === chatId); if (!user) return bot.sendMessage(chatId, "Please /start first."); user.phone = phone; user.awaiting_otp = true; saveUsers(users); if (!twilioClient) { bot.sendMessage(chatId, message('otp_failed', user)); console.error('Twilio client not initialized - cannot send OTP.'); return; } try { await twilioClient.verify.v2.services(TWILIO_VERIFY_SID).verifications.create({ to: phone, channel: 'sms' }); bot.sendMessage(chatId, message('otp_sent', user, phone)); } catch (err) { console.error('Twilio send OTP error:', err && err.message ? err.message : err); bot.sendMessage(chatId, ${message('otp_failed', user)}\n(${err && err.message ? err.message : 'unknown error'})); } });

// --- main message handler --- bot.on('message', async (msg) => { const chatId = msg.chat.id; const text = (msg.text || '').trim(); if (msg.contact) return; // handled upstream let users = loadUsers(); let user = users.find(u => u.telegram_id === chatId); if (!user) { user = { telegram_id: chatId, verified: false, phone: null, balance: 0, total_waste: 0, awaiting_otp: false, awaiting_waste: false, awaiting_withdraw: false, language: loadJSON(SETTINGS_FILE).language_default || 'en' }; users.push(user); saveUsers(users); }

// OTP check if (user.awaiting_otp && /^\d{4,6}$/.test(text)) { if (!twilioClient) return bot.sendMessage(chatId, message('otp_failed', user)); try { const chk = await twilioClient.verify.v2.services(TWILIO_VERIFY_SID).verificationChecks.create({ to: user.phone, code: text }); if (chk && chk.status === 'approved') { user.verified = true; user.awaiting_otp = false; saveUsers(users); return bot.sendMessage(chatId, message('verified_ok', user)); } return bot.sendMessage(chatId, '‚ùå Invalid code'); } catch (e) { console.error('Twilio verify error', e && e.message ? e.message : e); return bot.sendMessage(chatId, '‚ö†Ô∏è Verification failed'); } }

// Manual phone input if (!user.verified && loadJSON(SETTINGS_FILE).verification_enabled && /^+?\d{7,15}$/.test(text)) { user.phone = text; user.awaiting_otp = true; saveUsers(users); if (!twilioClient) return bot.sendMessage(chatId, message('otp_failed', user)); try { await twilioClient.verify.v2.services(TWILIO_VERIFY_SID).verifications.create({ to: text, channel: 'sms' }); bot.sendMessage(chatId, message('otp_sent', user, text)); } catch (err) { console.error('Twilio send OTP error:', err); bot.sendMessage(chatId, ${message('otp_failed', user)}\n(${err && err.message ? err.message : 'unknown'})); } return; }

if (!user.verified && loadJSON(SETTINGS_FILE).verification_enabled) return bot.sendMessage(chatId, message('need_verify', user));

// Photo uploads if (msg.photo && msg.photo.length) { const fileId = msg.photo[msg.photo.length - 1].file_id; try { const filePath = await bot.getFileLink(fileId); const response = await axios.get(filePath, { responseType: 'arraybuffer', timeout: 20000 }); const filename = upload_${chatId}_${Date.now()}.jpg; fs.writeFileSync(path.join(UPLOADS_DIR, filename), response.data); user.awaiting_waste = true; user.last_upload = filename; saveUsers(users); return bot.sendMessage(chatId, üì∏ Photo saved as ${filename}. Please reply with the weight in KG.); } catch (err) { console.error('Failed to save image', err); return bot.sendMessage(chatId, '‚ùå Failed to process the photo.'); } }

// Weight input after photo if (user.awaiting_waste && /^\d+(.\d+)?$/.test(text)) { const kg = parseFloat(text); const earned = kg * 120; user.total_waste = (user.total_waste || 0) + kg; user.balance = (user.balance || 0) + earned; user.awaiting_waste = false; saveUsers(users); return bot.sendMessage(chatId, message('recorded', user, kg, earned)); }

// Menu if (text === '/menu' || text.toLowerCase() === 'menu') { const buttons = [[{ text: '‚ôªÔ∏è Scan Waste' }], [{ text: 'üí∞ Withdraw' }], [{ text: 'üìä My Stats' }], [{ text: 'üîÅ Change Language' }]]; if (ADMIN_TELEGRAM_ID === chatId) buttons.push([{ text: 'üõ† Admin Panel' }]); return bot.sendMessage(chatId, message('main_menu', user), { reply_markup: { keyboard: buttons, resize_keyboard: true } }); }

if (text === '‚ôªÔ∏è Scan Waste') { user.awaiting_waste = true; saveUsers(users); return bot.sendMessage(chatId, 'üì∏ Send photo or type weight in KG'); }

if (text === 'üí∞ Withdraw') { if (!loadJSON(SETTINGS_FILE).withdrawals_enabled) return bot.sendMessage(chatId, 'Withdrawals disabled'); if ((user.balance || 0) < 1000) return bot.sendMessage(chatId, message('min_withdraw', user)); user.awaiting_withdraw = true; saveUsers(users); return bot.sendMessage(chatId, üí≥ Balance ‚Ç¶${(user.balance||0).toFixed(2)}\nSend your account info); }

if (user.awaiting_withdraw) { user.awaiting_withdraw = false; user.pending_withdrawal = { amount: user.balance, info: text, status: 'pending', requested_at: new Date().toISOString() }; saveUsers(users); bot.sendMessage(chatId, message('withdraw_received', user)); if (ADMIN_TELEGRAM_ID) bot.sendMessage(ADMIN_TELEGRAM_ID, üí∞ Withdrawal request from ${user.phone || user.telegram_id}\n‚Ç¶${user.balance}\nInfo: ${text}\nApprove: /approve ${chatId}\nReject: /reject ${chatId}); return; }

if (text === 'üìä My Stats') return bot.sendMessage(chatId, message('stats', user, user.total_waste || 0, user.balance || 0));

// Admin commands if (text === 'üõ† Admin Panel' && ADMIN_TELEGRAM_ID === chatId) return bot.sendMessage(chatId, '/approve <id>\n/reject <id>\n/toggle_verification\n/toggle_withdrawals\n/users');

if (text.startsWith('/approve') && ADMIN_TELEGRAM_ID === chatId) { const id = text.split(/\s+/)[1]; let all = loadUsers(); const u = all.find(x => String(x.telegram_id) === String(id)); if (!u?.pending_withdrawal) return bot.sendMessage(chatId, 'No pending withdrawal'); u.balance = 0; u.pending_withdrawal.status = 'approved'; saveUsers(all); bot.sendMessage(u.telegram_id, '‚úÖ Withdrawal approved!'); return bot.sendMessage(chatId, 'Approved.'); } if (text.startsWith('/reject') && ADMIN_TELEGRAM_ID === chatId) { const id = text.split(/\s+/)[1]; let all = loadUsers(); const u = all.find(x => String(x.telegram_id) === String(id)); if (!u?.pending_withdrawal) return bot.sendMessage(chatId, 'No pending withdrawal'); u.pending_withdrawal.status = 'rejected'; saveUsers(all); bot.sendMessage(u.telegram_id, '‚ùå Withdrawal rejected.'); return bot.sendMessage(chatId, 'Rejected.'); } if (text === '/toggle_verification' && ADMIN_TELEGRAM_ID === chatId) { const s = loadJSON(SETTINGS_FILE); s.verification_enabled = !s.verification_enabled; saveJSON(SETTINGS_FILE, s); return bot.sendMessage(chatId, Verification: ${s.verification_enabled}); } if (text === '/toggle_withdrawals' && ADMIN_TELEGRAM_ID === chatId) { const s = loadJSON(SETTINGS_FILE); s.withdrawals_enabled = !s.withdrawals_enabled; saveJSON(SETTINGS_FILE, s); return bot.sendMessage(chatId, Withdrawals: ${s.withdrawals_enabled}); }

if (text.startsWith('/users') && ADMIN_TELEGRAM_ID === chatId) { const all = loadUsers(); const list = all.map(u => ${u.telegram_id} | ${u.phone||'nophone'} | ‚Ç¶${(u.balance||0).toFixed(2)} | verified:${u.verified}).slice(0,200).join('\n'); return bot.sendMessage(chatId, üë• Users:\n${list || 'No users yet.'}); }

// fallback return bot.sendMessage(chatId, message('ai_reply', user, msg.from && msg.from.first_name ? msg.from.first_name : '')); });

// --- Express health + keepalive --- const app = express(); app.get('/health', (req, res) => res.json({ status: 'ok', time: new Date().toISOString() })); app.get('/', (req, res) => res.send('ü§ñ Bot is live and healthy!'));

// Start server const server = app.listen(PORT, '0.0.0.0', () => { console.log(üöÄ Server running on port ${PORT});

// keep-alive ping to localhost to satisfy Railway if desired setInterval(() => { axios.get(http://localhost:${PORT}/health).then(() => console.log('‚úÖ Keep-alive ping sent')).catch((err) => console.warn('‚ö†Ô∏è Keep-alive failed', err && err.message ? err.message : err)); }, 4 * 60 * 1000); });

// --- Polling error handling: if unauthorized, exit so Railway restarter can pick correct config --- bot.on('polling_error', (err) => { try { const code = err && err.code ? err.code : (err && err.response && err.response.status ? err.response.status : 'UNKNOWN'); console.error('Polling error:', err && err.toString ? err.toString() : err); if (String(code) === 'ETELEGRAM' || (err && err.response && err.response.status === 401)) { console.error('Unauthorized: TELEGRAM_TOKEN invalid. Exiting.'); process.exit(1); } } catch (e) { console.error('Error in polling_error handler', e); } });

// Graceful shutdown function shutdown() { console.log('Shutting down...'); try { bot.stopPolling(); } catch (e) {} try { server.close(); } catch (e) {} process.exit(0); } process.on('SIGINT', shutdown); process.on('SIGTERM', shutdown);

